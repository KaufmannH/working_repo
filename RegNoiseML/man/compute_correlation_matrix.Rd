% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helper_functions.R
\name{compute_correlation_matrix}
\alias{compute_correlation_matrix}
\title{Compute a Correlation Matrix in Parallel Blocks}
\usage{
compute_correlation_matrix(
  predictors,
  correlation_threshold = 0.9,
  n_cores = 4,
  block_size = 50,
  return_corr_matrix = FALSE
)
}
\arguments{
\item{predictors}{A data frame, tibble, or data.table containing predictor variables.
Only numeric columns are included in the correlation computation.}

\item{correlation_threshold}{Numeric. Predictors with correlations above this value will be filtered.}

\item{n_cores}{Integer. Number of CPU cores to use for parallel computation.
On macOS, using multiple cores may not speed up computation due to BLAS threading.}

\item{block_size}{Integer. Number of columns to include per processing block.}

\item{return_corr_matrix}{Boolean. Returns a list of high_corr + cor_matrix if TRUE.}
}
\value{
Column names of predictors that are highly correlated, for filtering.
Optional (return_corr_matrix): a list object with the standard return and
a numeric correlation matrix of size \code{p Ã— p}, where \code{p}
  is the number of numeric columns in \code{predictors}.
}
\description{
Efficiently computes a full correlation matrix for all numeric columns
in a data frame or tibble, using parallel block-wise computation.
}
\details{
This function divides the numeric columns into blocks and computes correlations
in parallel to handle wide datasets efficiently. The final output is assembled
into a complete correlation matrix.


Internally, this function:
\enumerate{
  \item Selects numeric columns from the input.
  \item Converts them to a matrix for fast computation.
  \item Splits columns into blocks and computes correlations in parallel using \code{parallel::mclapply()}.
  \item Combines all block results into a full symmetric correlation matrix.
}
}
\examples{
set.seed(42)
df <- tibble(
  x = rnorm(100),
  y = rnorm(100),
  z = rnorm(100),
  group = sample(letters[1:3], 100, replace = TRUE)
)

cor_mat <- compute_correlation_matrix(df, n_cores = 2, block_size = 2)
print(dim(cor_mat))

}
\seealso{
[parallel::mclapply()], [stats::cor()]
}
